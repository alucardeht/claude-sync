const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const config = require('./config');
const git = require('./git');
const chalk = require('chalk');
const { pathStartsWith } = require('./pathUtils');
const os = require('os');

class Syncer {
  async syncAll() {
    const workspaces = config.listWorkspaces();

    if (!workspaces || workspaces.length === 0) {
      throw new Error('No workspaces registered. Use "claude-sync add <path>" to add workspaces.');
    }

    const results = [];

    // Sync all workspaces locally (regenerate CLAUDE.md)
    for (const workspace of workspaces) {
      try {
        const result = await this.syncWorkspace(workspace.path);
        results.push({ workspace: workspace.name, ...result });
      } catch (error) {
        results.push({
          workspace: workspace.name,
          success: false,
          error: error.message,
        });
      }
    }

    // Push CLAUDE-GLOBAL.md to GitHub as CLAUDE.md
    // Find the most recently modified CLAUDE-GLOBAL.md across all workspaces
    const syncRules = config.get('syncRules');
    let globalFile = null;
    let latestMtime = 0;

    for (const workspace of workspaces) {
      const candidate = path.join(workspace.path, syncRules.globalFile);
      if (fs.existsSync(candidate)) {
        const stat = fs.statSync(candidate);
        if (stat.mtimeMs > latestMtime) {
          latestMtime = stat.mtimeMs;
          globalFile = candidate;
        }
      }
    }

    if (globalFile) {
      try {
        const gitResult = await this.syncGlobalToGitHub(globalFile);
        results.push({
          workspace: 'GitHub',
          ...gitResult,
        });
      } catch (error) {
        results.push({
          workspace: 'GitHub',
          success: false,
          error: error.message,
        });
      }
    }

    config.set('lastSync', new Date().toISOString());

    return results;
  }

  async syncWorkspace(workspacePath) {
    const syncRules = config.get('syncRules');

    const globalFile = path.join(workspacePath, syncRules.globalFile);
    const projectFile = path.join(workspacePath, syncRules.projectFile);
    const targetFile = path.join(workspacePath, syncRules.targetFile);

    if (!fs.existsSync(globalFile) && !fs.existsSync(projectFile)) {
      return {
        success: false,
        message: `Neither ${syncRules.globalFile} nor ${syncRules.projectFile} found in workspace`,
      };
    }

    let globalContent = '';
    let projectContent = '';

    if (fs.existsSync(globalFile)) {
      globalContent = fs.readFileSync(globalFile, 'utf8');
    }

    if (fs.existsSync(projectFile)) {
      projectContent = fs.readFileSync(projectFile, 'utf8');
    }

    const mergedContent = this.mergeContent(globalContent, projectContent);

    fs.writeFileSync(targetFile, mergedContent, 'utf8');

    return {
      success: true,
      message: `Successfully synced ${syncRules.targetFile}`,
      hasGlobal: fs.existsSync(globalFile),
      hasProject: fs.existsSync(projectFile),
    };
  }

  mergeContent(globalContent, projectContent) {
    if (!globalContent && !projectContent) {
      return '';
    }

    const header =
      '<!-- DO NOT EDIT THIS FILE DIRECTLY -->\n' +
      '<!-- This file is auto-generated by claude-sync. -->\n' +
      '<!-- Edit CLAUDE-GLOBAL.md for shared rules or CLAUDE-PROJECT.md for project rules. -->\n' +
      '<!-- Changes made here will be OVERWRITTEN on the next sync. -->\n\n';

    if (!globalContent) {
      return header + projectContent;
    }

    if (!projectContent) {
      return header + globalContent;
    }

    const separator = '\n\n---\n\n# Project-Specific Configuration\n\n';
    return header + globalContent.trim() + separator + projectContent.trim() + '\n';
  }

  async syncGlobalToGitHub(globalFilePath) {
    if (!fs.existsSync(globalFilePath)) {
      throw new Error(`CLAUDE-GLOBAL.md not found: ${globalFilePath}`);
    }

    try {
      const today = new Date().toISOString().split('T')[0];
      const result = await git.syncFile(
        globalFilePath,
        `Update global rules - ${today}`,
        'CLAUDE.md'  // Save as CLAUDE.md in GitHub
      );

      config.set('lastSync', new Date().toISOString());

      return result;
    } catch (error) {
      throw new Error(`Failed to sync to GitHub: ${error.message}`);
    }
  }

  async syncToGitHub(sourcePath) {
    // Legacy method - redirects to syncGlobalToGitHub
    return this.syncGlobalToGitHub(sourcePath);
  }

  async propagateFromGitHub({ skipPull = false } = {}) {
    const repoPath = git.getRepoPath();
    const syncRules = config.get('syncRules');
    const githubClaudeFile = path.join(repoPath, 'CLAUDE.md');

    // Pull latest changes from GitHub BEFORE checking file existence
    if (!skipPull) {
      await git.pull();
    }

    if (!fs.existsSync(githubClaudeFile)) {
      throw new Error('CLAUDE.md not found in GitHub repository');
    }

    const workspaces = config.listWorkspaces();
    const results = [];

    // Propagate GitHub/CLAUDE.md to each workspace as CLAUDE-GLOBAL.md
    for (const workspace of workspaces) {
      try {
        const targetGlobalPath = path.join(workspace.path, syncRules.globalFile);
        fs.copyFileSync(githubClaudeFile, targetGlobalPath);

        // Regenerate merged CLAUDE.md
        await this.syncWorkspace(workspace.path);

        results.push({
          workspace: workspace.name,
          success: true,
          message: 'Successfully propagated from GitHub and regenerated CLAUDE.md',
        });
      } catch (error) {
        results.push({
          workspace: workspace.name,
          success: false,
          error: error.message,
        });
      }
    }

    return results;
  }

  async propagateGlobalToWorkspaces(excludeWorkspacePath = null) {
    const repoPath = git.getRepoPath();
    const syncRules = config.get('syncRules');
    const githubClaudeFile = path.join(repoPath, 'CLAUDE.md');

    if (!fs.existsSync(githubClaudeFile)) {
      throw new Error('CLAUDE.md not found in GitHub repository');
    }

    const workspaces = config.listWorkspaces();
    const results = [];

    // Normalize the exclude path for comparison
    const normalizedExcludePath = excludeWorkspacePath ? path.resolve(excludeWorkspacePath) : null;

    // Propagate to all workspaces except the one that triggered the change
    for (const workspace of workspaces) {
      const normalizedWorkspacePath = path.resolve(workspace.path);

      if (normalizedExcludePath && normalizedWorkspacePath === normalizedExcludePath) {
        console.log(chalk.gray(`⏭️  Skipping ${workspace.name} (origin of change)`));
        continue;
      }

      try {
        const targetGlobalPath = path.join(workspace.path, syncRules.globalFile);
        const sourceContent = fs.readFileSync(githubClaudeFile, 'utf8');
        const targetContent = fs.existsSync(targetGlobalPath) ? fs.readFileSync(targetGlobalPath, 'utf8') : '';

        // Only update if content is different
        if (sourceContent !== targetContent) {
          fs.copyFileSync(githubClaudeFile, targetGlobalPath);

          // Regenerate merged CLAUDE.md
          await this.syncWorkspace(workspace.path);

          results.push({
            workspace: workspace.name,
            success: true,
            message: 'Successfully propagated global rules',
          });
        } else {
          console.log(chalk.gray(`⏭️  Skipping ${workspace.name} (already up to date)`));
        }
      } catch (error) {
        results.push({
          workspace: workspace.name,
          success: false,
          error: error.message,
        });
      }
    }

    return results;
  }

  async syncSkillToGitHub(skillFilePath) {
    if (!fs.existsSync(skillFilePath)) {
      throw new Error(`Skill file not found: ${skillFilePath}`);
    }

    const globalSkillsPath = path.join(os.homedir(), '.claude', 'skills');

    if (!pathStartsWith(skillFilePath, globalSkillsPath)) {
      return {
        pushed: false,
        message: 'Skill is project-specific, not synced to GitHub',
      };
    }

    const relativePath = path.relative(globalSkillsPath, skillFilePath);
    const targetPath = path.join('skills', relativePath);

    try {
      const today = new Date().toISOString().split('T')[0];
      const skillName = path.basename(path.dirname(skillFilePath));
      const result = await git.syncFile(
        skillFilePath,
        `Update skill: ${skillName} - ${today}`,
        targetPath
      );

      return result;
    } catch (error) {
      throw new Error(`Failed to sync skill to GitHub: ${error.message}`);
    }
  }

  async propagateSkillsFromGitHub({ skipPull = false, force = false } = {}) {
    const repoPath = git.getRepoPath();
    const githubSkillsDir = path.join(repoPath, 'skills');

    // Pull BEFORE checking directory existence (it may only exist on remote)
    if (!skipPull) {
      await git.pull();
    }

    if (!fs.existsSync(githubSkillsDir)) {
      return {
        success: true,
        message: 'No skills directory in GitHub repository',
        skippedFiles: [],
      };
    }

    const globalSkillsPath = path.join(os.homedir(), '.claude', 'skills');

    if (!fs.existsSync(globalSkillsPath)) {
      fs.mkdirSync(globalSkillsPath, { recursive: true });
    }

    const manifest = this._loadManifest();
    const skippedFiles = [];

    const copyDir = (src, dest) => {
      if (!fs.existsSync(dest)) {
        fs.mkdirSync(dest, { recursive: true });
      }

      const entries = fs.readdirSync(src, { withFileTypes: true });

      for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);

        if (entry.isDirectory()) {
          copyDir(srcPath, destPath);
        } else {
          if (!force && fs.existsSync(destPath)) {
            const srcContent = fs.readFileSync(srcPath, 'utf8');
            const destContent = fs.readFileSync(destPath, 'utf8');

            if (srcContent === destContent) {
              const relKey = 'skills/' + path.relative(globalSkillsPath, destPath).replace(/\\/g, '/');
              manifest[relKey] = this._contentHash(destContent);
              continue;
            }

            const relKey = 'skills/' + path.relative(globalSkillsPath, destPath).replace(/\\/g, '/');
            const destHash = this._contentHash(destContent);
            const lastSyncedHash = manifest[relKey];

            if (lastSyncedHash && destHash !== lastSyncedHash) {
              skippedFiles.push({
                file: path.relative(globalSkillsPath, destPath),
                reason: 'local has been edited since last sync',
              });
              continue;
            }
          }

          fs.copyFileSync(srcPath, destPath);

          const relKey = 'skills/' + path.relative(globalSkillsPath, destPath).replace(/\\/g, '/');
          manifest[relKey] = this._contentHash(fs.readFileSync(destPath, 'utf8'));
        }
      }
    };

    copyDir(githubSkillsDir, globalSkillsPath);
    this._saveManifest(manifest);

    return {
      success: true,
      message: skippedFiles.length > 0
        ? `Propagated skills (${skippedFiles.length} skipped - local has been edited)`
        : 'Successfully propagated skills from GitHub',
      skippedFiles,
    };
  }

  async syncAllGlobalSkills() {
    const globalSkillsPath = path.join(os.homedir(), '.claude', 'skills');

    if (!fs.existsSync(globalSkillsPath)) {
      return {
        success: false,
        message: 'No global skills directory found',
        synced: 0,
        failed: 0,
      };
    }

    const results = {
      success: true,
      synced: 0,
      failed: 0,
      details: [],
    };

    const skillDirs = fs.readdirSync(globalSkillsPath, { withFileTypes: true })
      .filter(entry => entry.isDirectory())
      .map(entry => entry.name);

    for (const skillDir of skillDirs) {
      const skillDirPath = path.join(globalSkillsPath, skillDir);
      
      const skillFiles = fs.readdirSync(skillDirPath)
        .filter(file => file.toLowerCase() === 'skill.md');

      if (skillFiles.length === 0) {
        results.details.push({
          skill: skillDir,
          status: 'skipped',
          message: 'No skill file found (SKILL.md or skill.md)',
        });
        continue;
      }

      const skillFilePath = path.join(skillDirPath, skillFiles[0]);

      try {
        const syncResult = await this.syncSkillToGitHub(skillFilePath);
        
        if (syncResult.pushed) {
          results.synced++;
          results.details.push({
            skill: skillDir,
            status: 'synced',
            message: 'Successfully synced to GitHub',
          });
        } else {
          results.details.push({
            skill: skillDir,
            status: 'skipped',
            message: syncResult.message,
          });
        }
      } catch (error) {
        results.failed++;
        results.success = false;
        results.details.push({
          skill: skillDir,
          status: 'failed',
          message: error.message,
        });
      }
    }

    return results;
  }

  async syncAgentToGitHub(agentFilePath) {
    if (!fs.existsSync(agentFilePath)) {
      throw new Error(`Agent file not found: ${agentFilePath}`);
    }

    const globalAgentsPath = path.join(os.homedir(), '.claude', 'agents');

    if (!pathStartsWith(agentFilePath, globalAgentsPath)) {
      return {
        pushed: false,
        message: 'Agent is project-specific, not synced to GitHub',
      };
    }

    const agentFileName = path.basename(agentFilePath);
    const targetPath = path.join('agents', agentFileName);

    try {
      const today = new Date().toISOString().split('T')[0];
      const agentName = path.basename(agentFilePath, '.md');
      const result = await git.syncFile(
        agentFilePath,
        `Update agent: ${agentName} - ${today}`,
        targetPath
      );

      return result;
    } catch (error) {
      throw new Error(`Failed to sync agent to GitHub: ${error.message}`);
    }
  }

  async propagateAgentsFromGitHub({ skipPull = false, force = false } = {}) {
    const repoPath = git.getRepoPath();
    const githubAgentsDir = path.join(repoPath, 'agents');

    // Pull BEFORE checking directory existence (it may only exist on remote)
    if (!skipPull) {
      await git.pull();
    }

    if (!fs.existsSync(githubAgentsDir)) {
      return {
        success: true,
        message: 'No agents directory in GitHub repository',
        skippedFiles: [],
      };
    }

    const globalAgentsPath = path.join(os.homedir(), '.claude', 'agents');

    if (!fs.existsSync(globalAgentsPath)) {
      fs.mkdirSync(globalAgentsPath, { recursive: true });
    }

    const manifest = this._loadManifest();
    const skippedFiles = [];

    const agentFiles = fs.readdirSync(githubAgentsDir)
      .filter(file => file.endsWith('.md'));

    for (const agentFile of agentFiles) {
      const srcPath = path.join(githubAgentsDir, agentFile);
      const destPath = path.join(globalAgentsPath, agentFile);

      if (!force && fs.existsSync(destPath)) {
        const srcContent = fs.readFileSync(srcPath, 'utf8');
        const destContent = fs.readFileSync(destPath, 'utf8');

        if (srcContent === destContent) {
          manifest['agents/' + agentFile] = this._contentHash(destContent);
          continue;
        }

        const destHash = this._contentHash(destContent);
        const lastSyncedHash = manifest['agents/' + agentFile];

        if (lastSyncedHash && destHash !== lastSyncedHash) {
          skippedFiles.push({
            file: agentFile,
            reason: 'local has been edited since last sync',
          });
          continue;
        }
      }

      fs.copyFileSync(srcPath, destPath);
      manifest['agents/' + agentFile] = this._contentHash(fs.readFileSync(destPath, 'utf8'));
    }

    this._saveManifest(manifest);

    return {
      success: true,
      message: skippedFiles.length > 0
        ? `Propagated agents (${skippedFiles.length} skipped - local has been edited)`
        : 'Successfully propagated agents from GitHub',
      skippedFiles,
    };
  }

  async syncAllGlobalAgents() {
    const globalAgentsPath = path.join(os.homedir(), '.claude', 'agents');

    if (!fs.existsSync(globalAgentsPath)) {
      return {
        success: false,
        message: 'No global agents directory found',
        synced: 0,
        failed: 0,
      };
    }

    const results = {
      success: true,
      synced: 0,
      failed: 0,
      details: [],
    };

    const agentFiles = fs.readdirSync(globalAgentsPath)
      .filter(file => file.endsWith('.md'));

    for (const agentFile of agentFiles) {
      const agentFilePath = path.join(globalAgentsPath, agentFile);
      const agentName = path.basename(agentFile, '.md');

      try {
        const syncResult = await this.syncAgentToGitHub(agentFilePath);

        if (syncResult.pushed) {
          results.synced++;
          results.details.push({
            agent: agentName,
            status: 'synced',
            message: 'Successfully synced to GitHub',
          });
        } else {
          results.details.push({
            agent: agentName,
            status: 'skipped',
            message: syncResult.message,
          });
        }
      } catch (error) {
        results.failed++;
        results.success = false;
        results.details.push({
          agent: agentName,
          status: 'failed',
          message: error.message,
        });
      }
    }

    return results;
  }

  async removeAgentFromGitHub(agentFilePath) {
    const globalAgentsPath = path.join(os.homedir(), '.claude', 'agents');

    if (!pathStartsWith(agentFilePath, globalAgentsPath)) {
      return {
        removed: false,
        message: 'Agent is project-specific, not synced to GitHub',
      };
    }

    const agentFileName = path.basename(agentFilePath);
    const targetPath = path.join('agents', agentFileName);
    const repoPath = git.getRepoPath();
    const fullTargetPath = path.join(repoPath, targetPath);

    if (!fs.existsSync(fullTargetPath)) {
      return {
        removed: false,
        message: 'Agent not found in GitHub repository',
      };
    }

    try {
      const today = new Date().toISOString().split('T')[0];
      const agentName = path.basename(agentFilePath, '.md');

      fs.unlinkSync(fullTargetPath);

      const result = await git.syncFile(
        fullTargetPath,
        `Remove agent: ${agentName} - ${today}`,
        targetPath,
        true
      );

      return { removed: true, message: 'Successfully removed agent from GitHub' };
    } catch (error) {
      throw new Error(`Failed to remove agent from GitHub: ${error.message}`);
    }
  }

  async removeSkillFromGitHub(skillFilePath) {
    const globalSkillsPath = path.join(os.homedir(), '.claude', 'skills');

    if (!pathStartsWith(skillFilePath, globalSkillsPath)) {
      return {
        removed: false,
        message: 'Skill is project-specific, not synced to GitHub',
      };
    }

    const relativePath = path.relative(globalSkillsPath, skillFilePath);
    const targetPath = path.join('skills', relativePath);
    const repoPath = git.getRepoPath();
    const fullTargetPath = path.join(repoPath, targetPath);

    if (!fs.existsSync(fullTargetPath)) {
      return {
        removed: false,
        message: 'Skill not found in GitHub repository',
      };
    }

    try {
      const today = new Date().toISOString().split('T')[0];
      const skillName = path.basename(path.dirname(skillFilePath));

      fs.unlinkSync(fullTargetPath);

      const skillDir = path.dirname(fullTargetPath);
      if (fs.existsSync(skillDir) && fs.readdirSync(skillDir).length === 0) {
        fs.rmdirSync(skillDir);
      }

      const result = await git.syncFile(
        fullTargetPath,
        `Remove skill: ${skillName} - ${today}`,
        targetPath,
        true
      );

      return { removed: true, message: 'Successfully removed skill from GitHub' };
    } catch (error) {
      throw new Error(`Failed to remove skill from GitHub: ${error.message}`);
    }
  }

  async dryRunSyncAll() {
    const workspaces = config.listWorkspaces();

    if (!workspaces || workspaces.length === 0) {
      return { actions: [], message: 'No workspaces registered' };
    }

    const actions = [];
    const syncRules = config.get('syncRules');

    for (const workspace of workspaces) {
      const globalFile = path.join(workspace.path, syncRules.globalFile);
      const projectFile = path.join(workspace.path, syncRules.projectFile);
      const targetFile = path.join(workspace.path, syncRules.targetFile);

      const hasGlobal = fs.existsSync(globalFile);
      const hasProject = fs.existsSync(projectFile);
      const hasTarget = fs.existsSync(targetFile);

      if (!hasGlobal && !hasProject) {
        actions.push({ workspace: workspace.name, action: 'skip', reason: `Neither ${syncRules.globalFile} nor ${syncRules.projectFile} found` });
        continue;
      }

      let globalContent = '';
      let projectContent = '';
      if (hasGlobal) globalContent = fs.readFileSync(globalFile, 'utf8');
      if (hasProject) projectContent = fs.readFileSync(projectFile, 'utf8');

      const mergedContent = this.mergeContent(globalContent, projectContent);
      const currentContent = hasTarget ? fs.readFileSync(targetFile, 'utf8') : '';

      if (mergedContent === currentContent) {
        actions.push({ workspace: workspace.name, action: 'skip', reason: 'CLAUDE.md already up to date' });
      } else {
        actions.push({ workspace: workspace.name, action: 'regenerate', reason: hasTarget ? 'CLAUDE.md would be updated' : 'CLAUDE.md would be created' });
      }
    }

    let latestGlobalFile = null;
    let latestMtime = 0;
    for (const workspace of workspaces) {
      const candidate = path.join(workspace.path, syncRules.globalFile);
      if (fs.existsSync(candidate)) {
        const stat = fs.statSync(candidate);
        if (stat.mtimeMs > latestMtime) {
          latestMtime = stat.mtimeMs;
          latestGlobalFile = candidate;
        }
      }
    }

    if (latestGlobalFile) {
      const repoPath = git.getRepoPath();
      const repoClaudeFile = path.join(repoPath, 'CLAUDE.md');
      if (fs.existsSync(repoClaudeFile)) {
        const localContent = fs.readFileSync(latestGlobalFile, 'utf8');
        const repoContent = fs.readFileSync(repoClaudeFile, 'utf8');
        if (localContent === repoContent) {
          actions.push({ workspace: 'GitHub', action: 'skip', reason: 'GitHub CLAUDE.md already matches local' });
        } else {
          actions.push({ workspace: 'GitHub', action: 'push', reason: 'CLAUDE-GLOBAL.md would be pushed to GitHub' });
        }
      } else {
        actions.push({ workspace: 'GitHub', action: 'push', reason: 'CLAUDE.md would be created on GitHub' });
      }
    }

    return { actions };
  }

  async dryRunSyncSkills() {
    const globalSkillsPath = path.join(os.homedir(), '.claude', 'skills');
    if (!fs.existsSync(globalSkillsPath)) {
      return { actions: [], message: 'No global skills directory found' };
    }

    const actions = [];
    const repoPath = git.getRepoPath();
    const skillDirs = fs.readdirSync(globalSkillsPath, { withFileTypes: true })
      .filter(entry => entry.isDirectory())
      .map(entry => entry.name);

    for (const skillDir of skillDirs) {
      const skillDirPath = path.join(globalSkillsPath, skillDir);
      const skillFiles = fs.readdirSync(skillDirPath).filter(file => file.toLowerCase() === 'skill.md');

      if (skillFiles.length === 0) {
        actions.push({ skill: skillDir, action: 'skip', reason: 'No SKILL.md found' });
        continue;
      }

      const skillFilePath = path.join(skillDirPath, skillFiles[0]);
      const targetPath = path.join(repoPath, 'skills', skillDir, skillFiles[0]);

      if (fs.existsSync(targetPath)) {
        const localContent = fs.readFileSync(skillFilePath, 'utf8');
        const repoContent = fs.readFileSync(targetPath, 'utf8');
        if (localContent === repoContent) {
          actions.push({ skill: skillDir, action: 'skip', reason: 'Already up to date on GitHub' });
        } else {
          actions.push({ skill: skillDir, action: 'push', reason: 'Would be updated on GitHub' });
        }
      } else {
        actions.push({ skill: skillDir, action: 'push', reason: 'Would be created on GitHub' });
      }
    }

    return { actions };
  }

  async dryRunSyncAgents() {
    const globalAgentsPath = path.join(os.homedir(), '.claude', 'agents');
    if (!fs.existsSync(globalAgentsPath)) {
      return { actions: [], message: 'No global agents directory found' };
    }

    const actions = [];
    const repoPath = git.getRepoPath();
    const agentFiles = fs.readdirSync(globalAgentsPath).filter(file => file.endsWith('.md'));

    for (const agentFile of agentFiles) {
      const agentFilePath = path.join(globalAgentsPath, agentFile);
      const targetPath = path.join(repoPath, 'agents', agentFile);

      if (fs.existsSync(targetPath)) {
        const localContent = fs.readFileSync(agentFilePath, 'utf8');
        const repoContent = fs.readFileSync(targetPath, 'utf8');
        if (localContent === repoContent) {
          actions.push({ agent: path.basename(agentFile, '.md'), action: 'skip', reason: 'Already up to date on GitHub' });
        } else {
          actions.push({ agent: path.basename(agentFile, '.md'), action: 'push', reason: 'Would be updated on GitHub' });
        }
      } else {
        actions.push({ agent: path.basename(agentFile, '.md'), action: 'push', reason: 'Would be created on GitHub' });
      }
    }

    return { actions };
  }

  _getManifestPath() {
    return path.join(os.homedir(), '.config', 'claude-sync', 'sync-manifest.json');
  }

  _loadManifest() {
    try {
      const manifestPath = this._getManifestPath();
      if (fs.existsSync(manifestPath)) {
        return JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
      }
    } catch (e) {
      // Corrupt manifest - start fresh
    }
    return {};
  }

  _saveManifest(manifest) {
    const manifestPath = this._getManifestPath();
    const dir = path.dirname(manifestPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2), 'utf8');
  }

  _contentHash(content) {
    return crypto.createHash('sha256').update(content).digest('hex');
  }
}

module.exports = new Syncer();
